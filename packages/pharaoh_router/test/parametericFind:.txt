parametericFind:
        for (final paramNode in paramNodes) {
          if (debug) {
            debugLog.writeln('     *maybe?    :${paramNode.name}');
          }
          final currentPath = path.substring(i);
          String val = getPathParameter(currentPath);

          if (debug) {
            print('Current Path: $currentPath');
          }

          /// If there are any symbols in the current path segment,
          /// we need to be sure the current node doesn't have it as a child.
          ///
          /// we do find that the current node has it as a child, then,
          /// resolved parameter will be everything until that special character.
          final indexedSymbols = extractIndexedSymbols(currentPath);
          if (debug) {
            debugLog.writeln(
                '     *symbols:  ${indexedSymbols.map((e) => e.char).join(', ')}');
          }

          /// if we have symbols in the current path segment
          /// we need to verify that what we're capturing is the
          /// actual parameter.
          ///
          /// If we find no static nodes for the symbols,
          /// the whole string is written off as a parameter.
          ///
          /// eg: user-name/ -> will give us user as parameter. But then we have
          /// - and / as symbols.
          if (indexedSymbols.isNotEmpty) {
            for (final sym in indexedSymbols) {
              final symIndex = sym.index;
              final charAfterSymbol = symIndex + 1;
              final nextChar = currentPath[charAfterSymbol];

              final isActualNodeToUse = paramNode.hasChild(sym.char) &&
                  paramNode.getChild(sym.char).hasChild(nextChar);

              if (debug) {
                print(
                    'Val is $val and Sym is ${sym.char} and next is $nextChar');

                print(paramNode.hasChild(sym.char));
              }

              if (isActualNodeToUse) {
                if (debug) {
                  debugLog.writeln(
                      "- Found Static for             ->            _(${sym.char})_ and it's next $nextChar");
                }

                i += charAfterSymbol;
                rootNode = paramNode.getChild(sym.char).getChild(nextChar);
                resolvedParams[paramNode.name] = val;
                break parametericFind;
              } else {
                val = currentPath.substring(0, symIndex + 1);
              }
            }
          }

          final nextCharIndex = val.length + i;
          final endOfPath = nextCharIndex >= path.length;
          if (!endOfPath) {
            final nextChar = path[nextCharIndex];
            if (!paramNode.hasChild(nextChar)) continue;
          }

          if (!paramNode.terminal) continue;

          char = val;
          resolvedParams[paramNode.name] = char;
          rootNode = paramNode;
          i = nextCharIndex - 1;

          if (debug) {
            debugLog.writeln(
                '- Node :${paramNode.name} works for ->        $char  âœ…');
          }
          break;
        }